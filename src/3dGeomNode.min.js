const MapGen=function(){"use strict";function a(a){return Object.assign(Object.create(Object.getPrototypeOf(a)),a)}function b(a){return a.map(a=>a.road)}function c(a){return a.map(a=>[a.x,a.y,a.z])}function d(a){return a.map(a=>{const{vertices:b}=a;return a instanceof j?c([b.p1,b.p2,b.p3]):c([b.p1,b.p2,b.p3,b.p4])})}function e(a,c,e){const f=o.optMapGen(a,c,e),g=d(b(f));return g}function f(a,b,c){return JSON.stringify(e(a,b,c))}class g{constructor(a,b,c){if(isNaN(a)||isNaN(b)||isNaN(c)||0>a||0>b||0>c)throw console.log(a,b,c),new Error("Wrong arguments for position");this.x=a,this.y=b,this.z=c}decrease(a){if(["x","y","z"].includes(a))return this[a]-=1,this;throw new Error("Expected x, y, or z chars")}increase(a){if(["x","y","z"].includes(a))return this[a]+=1,this;throw new Error("Expected x, y, or z chars")}}class h{constructor(a){if(isNaN(a)||0>a||Math.floor(a)!==a)throw new Error("3D Array size must be a positive integer");this.content=[],this.size=a;for(let b=0;b<Math.pow(a,3);++b)this.content.push(null)}get(a){if(!(a instanceof g))throw console.log(a),new Error("Expected 3D Pos as argument, got "+JSON.stringify(a));const{x:b,y:c,z:d}=a,e=this.size;if(0>b||0>c||0>d||b>=e||c>=e||d>=e)throw new Error("Pos out of map bounds");return this.content[b*e*e+c*e+d]}set(a,b){if(!(a instanceof g))throw console.log(a),new Error("Expected 3D Pos as argument, got "+JSON.stringify(a));const{x:c,y:d,z:e}=a,f=this.size;if(0>c||0>d||0>e||c>=f||d>=f||e>=f)throw new Error("Pos out of map bounds");this.content[c*f*f+d*f+e]=b}getSucc(a,b){if(!(a instanceof g&&[1,3,5,7].includes(b)))throw console.log(a,b),new Error("Bad args for getting succ");const{x:c,y:d,z:e}=a,f=this.size;if(0>c||0>d||0>e||c>=f||d>=f||e>=f)throw new Error("Pos out of map bounds");const h=f-1;let i;const j="x",k=(a,b,c,d)=>{try{return a?j:this.get(new g(b,c,d))}catch(a){return j}},l=0>c-1,m=c+1>h,n=0>d-1,o=0>d-2,p=d+1>h,q=d+1>h,r=0>e-1,s=e+1>h;switch(b){case 1:i={left:k(l,c-1,d,e),right:k(m,c+1,d,e),forward:k(s,c,d,e+1),upward:k(s||n,c,d-1,e+1)&&k(o||s,c,d-2,e+1),downward:k(p||s,c,d+1,e+1)&&k(q||s,c,d+2,e+1),above:k(n,c,d-1,e)&&k(o,c,d-2,e),under:k(p,c,d+1,e)&&k(q,c,d+2,e),underL:k(p||l,c-1,d+1,e)&&k(q||l,c-1,d+2,e),underR:k(p||m,c+1,d+1,e)&&k(q||m,c+1,d+2,e)};break;case 3:i={left:k(s,c,d,e+1),right:k(r,c,d,e-1),forward:k(m,c+1,d,e),upward:k(m||n,c+1,d-1,e)||k(o||m,c+1,d+2,e),downward:k(m||p,c+1,d+1,e)||k(q||m,c+1,d+2,e),above:k(n,c,d-1,e)||k(o,c,d+2,e),under:k(p,c,d+1,e)||k(q,c,d+2,e),underL:k(p||s,c,d+1,e+1)||k(q||s,c,d+2,e+1),underR:k(p||r,c,d+1,e-1)||k(q||r,c,d+2,e-1)};break;case 5:i={left:k(m,c+1,d,e),right:k(l,c-1,d,e),forward:k(r,c,d,e-1),upward:k(r||n,c,d-1,e-1)&&k(o||r,c,d+2,e-1),downward:k(r||p,c,d+1,e-1)&&k(q||r,c,d+2,e-1),above:k(n,c,d-1,e)&&k(o,c,d+2,e),under:k(p,c,d+1,e)&&k(q,c,d+2,e),underL:k(p||m,c+1,d+1,e)&&k(q||m,c+1,d+2,e),underR:k(p||l,c-1,d+1,e)&&k(q||l,c-1,d+2,e)};break;case 7:i={left:k(r,c,d,e-1),right:k(s,c,d,e+1),forward:k(l,c-1,d,e),upward:k(n||l,c-1,d-1,e)&&k(o||l,c-1,d+2,e),downward:k(p||l,c-1,d+1,e)&&k(q||l,c-1,d+2,e),above:k(n,c,d-1,e)&&k(o,c,d+2,e),under:k(p,c,d+1,e)&&k(q,c,d+2,e),underL:k(p||r,c,d+1,e-1)&&k(q||r,c,d+2,e-1),underR:k(p||s,c,d+1,e+1)&&k(q||s,c,d+2,e+1)};break;default:}return i}}class i{constructor(a){if(Math.floor(a)!==a)throw new Error("Maps can only have integer sizes");if(1>a)throw new Error("Map size must be positive and greater than zero");this.size={x:a,y:a,z:a},this.voxels=new h(a)}}class j{constructor(a,b,c){if(a instanceof g&&b instanceof g&&c instanceof g)this.vertices={p1:a,p2:b,p3:c};else throw console.log(a,b,c),new Error("Wrong arguments for creating triangle")}}class k{constructor(a,b,c,d){if(a instanceof g&&b instanceof g&&c instanceof g&&d instanceof g)this.vertices={p1:a,p2:b,p3:c,p4:d};else throw new Error("Wrong arguments for creating plane")}}class l{constructor(a){if(a instanceof g)this.pos=a;else throw new Error("Wrong arguments for creating voxel")}getVertices(){const{x:a,y:b,z:c}=this.pos;let d=new g(a,b,c),e=new g(a+1,b,c),f=new g(a+1,b,c+1),h=new g(a,b,c+1);return new k(d,e,f,h)}}class m{constructor(a,b){if(!(isNaN(a)&&isNaN(b))){if(1>a||8<a||a!=Math.floor(a))throw new Error("Unaccepted orientation argument for direction");if(0!==b&&-1!==b&&1!==b)throw new Error("Unaccepted climb argument for direction");this.orientation=a,this.climb=b}else throw new Error("Wrong parameter types for direction")}}class n{constructor(a,b,c){if(!(a instanceof l&&b instanceof m&&[1,3,5,7].includes(c)))throw console.log(a,b,c),new Error("Wrong parameter types for road");this.voxel=a,this.direction=b,this.road=n.createRoadPlane(a,b,c)}static createRoadPlane(a,b,c){if(!(a instanceof l&&b instanceof m&&[1,3,5,7].includes(c)))throw new Error("Wrong parameter types for road plane");const{orientation:d,climb:e}=b,f=a.getVertices(),{p1:g,p2:h,p3:i,p4:n}=f.vertices,o=d+c,p=9<o?o-9:o-1;switch(p){case 1:return-1===e?new k(g,h,i.increase("y"),n.increase("y")):0===e?new k(g,h,i,n):new k(g,h,i.decrease("y"),n.decrease("y"));break;case 2:if(0===e){if(1===c)return new j(g,h,i);if(3===c)return new j(i,n,g)}else throw new Error("Cannot create non-horizontal diagonal road segment");break;case 3:return-1===e?new k(g,h.increase("y"),i.increase("y"),n):0===e?new k(g,h,i,n):new k(g,h.decrease("y"),i.decrease("y"),n);break;case 4:if(0===e){if(3===c)return new j(n,g,h);if(5===c)return new j(i,n,h)}else throw new Error("Cannot create non-horizontal diagonal road segment");break;case 5:return-1===e?new k(g.increase("y"),h.increase("y"),i,n):0===e?new k(g,h,i,n):new k(g.decrease("y"),h.decrease("y"),i,n);break;case 6:if(0===e){if(5===c)return new j(g,i,n);if(7===c)return new j(h,i,g)}else throw new Error("Cannot create non-horizontal diagonal road segment");break;case 7:return-1===e?new k(g.increase("y"),h,i,n.increase("y")):0===e?new k(g,h,i,n):new k(g.decrease("y"),h,i,n.decrease("y"));break;case 8:if(0===e){if(7===c)return new j(n,h,i);if(1===c)return new j(g,n,h)}else throw new Error("Cannot create non-horizontal diagonal road segment");break;default:throw console.log(p,d,c),new Error("Invalid orientation for creating road plane");}}}class o{static optMapGen(a,b,c){function d(e,g,h,i){if(e.length==a)return e;const j=g.pos;f.set(j,k);const l=j.decrease("y"),m=j.increase("y");f.set(l,k),f.set(m,k);const p=f.getSucc(j,h),q=o.computeOptions(p,i,b,c);if(0<q.length){const a=o.shuffleArray(q);for(let b of a){const a=new n(g,b,h);f.set(j,a),e.push(a);const{currentVoxel:c,shape:i,currentDirection:k}=o.computeStepConsequences(b,h,j),l=d(e,c,k,i);if(!1!==l)return l;e.pop()}}return f.set(j,null),f.set(l,null),f.set(m,null),!1}const e=new i(a),f=e.voxels,h=Math.floor(a/2),j=new g(h,h,0),k="marked";let m=new l(j);return d([],m,1,"none")}static shuffleArray(a){const b=a.slice();for(let c=b.length-1;0<c;c--){const a=Math.floor(Math.random()*(c+1));[b[c],b[a]]=[b[a],b[c]]}return b}static getRandomInt(a,b){return Math.floor(Math.random()*(b-a))+a}static computeStepConsequences(b,c,d){const{climb:e,orientation:f}=b;let g,h;1===f?(g="square",h=1):2===f?(g="triangle",h=3):8===f?(g="triangle",h=7):void 0;let i=c-1+h;9<=i&&(i-=8);let j=a(d);switch(1===i?j.increase("z"):3===i?j.increase("x"):5===i?j.decrease("z"):7===i?j.decrease("x"):void 0,e){case 1:j.decrease("y");break;case-1:j.increase("y");break;default:}const k=new l(j);return{currentVoxel:k,shape:g,currentDirection:i}}static computeOptions(a,b,c,d){let e=[];const f=null===a.forward,g=null===a.downward,h=null===a.under,i=null===a.above,j=null===a.left,k=null===a.right,l=null===a.underL,n=null===a.underR,o=null===a.upward;return j&&k&&l&&h&&"square"===b&&e.push(new m(8,0)),k&&j&&n&&h&&"square"===b&&e.push(new m(2,0)),j&&k&&o&&f&&i&&(e=e.concat(Array(d).fill(new m(1,1)))),j&&k&&g&&h&&f&&(e=e.concat(Array(d).fill(new m(1,-1)))),j&&k&&f&&g&&h&&(e=e.concat(Array(c).fill(new m(1,0)))),e}}const p=require("fs");return{getMap:e,generateJSONMap:f,writeJSONMapsToFiles:function(a,b,c,d){console.log(`Generating ${a} map(s) of size ${b}.`);for(let e=0;e<a;++e){const a=f(b,c,d);p.writeFileSync(`out/test${e}.json`,a,a=>{if(a)throw a}),console.log(`Generated map no ${e} of size ${JSON.parse(a).length}`)}}}}();